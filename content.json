{"meta":{"title":"潘先生的个人博客","subtitle":"","description":"","author":"Mr Pan","url":"http://example.com","root":"/"},"pages":[{"title":"文章分类","date":"2023-03-13T16:56:53.000Z","updated":"2023-03-13T17:02:00.988Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-03-12T15:32:24.000Z","updated":"2023-03-12T15:34:09.803Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"浅浅谈一下对CommonJS、AMD、CMD、ES Module的理解","slug":"浅浅谈一下对CommonJS、AMD、CMD、ES Module的理解","date":"2023-03-13T08:59:45.000Z","updated":"2023-03-13T15:37:33.430Z","comments":true,"path":"2023/03/13/浅浅谈一下对CommonJS、AMD、CMD、ES Module的理解/","link":"","permalink":"http://example.com/2023/03/13/%E6%B5%85%E6%B5%85%E8%B0%88%E4%B8%80%E4%B8%8B%E5%AF%B9CommonJS%E3%80%81AMD%E3%80%81CMD%E3%80%81ES%20Module%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"一、CommonJS1、大概的意思就是每一个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件是不可见。&emsp;2、CommonJS规范还规定了，每个模块内部有两个变量可以使用，require和module。","text":"一、CommonJS1、大概的意思就是每一个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件是不可见。&emsp;2、CommonJS规范还规定了，每个模块内部有两个变量可以使用，require和module。 require用来加载某个模块module代表当前模块是一个对象，保存了当前模块的信息。exports是module上的一个属性，保存了当前模块要导出的接口或者变量，使用require加载的某个获取到的就是那个模块使用exports导出的值 3、exports&emsp;为了方便，Node.js在实现CommonJS规范时，为每个模块提高一个exports的私有变量，指向的是module.exports。 4、require&emsp;require命令的基本功能是，读入并执行一个js文件，然后返回该模块的exports对象，如果没有发现指定模块，会报错。第一次加载某个模块时，Node.js会缓存该模块，以后再加载该模块，就直接从缓存取出改模块的module.exports属性返回了 12345678910111213//a.jsvar name =&#x27;morrain&#x27;var age =18module.exports.name=namemodule.exports.getAge=function()&#123; return age&#125;//b.jsvar a=require(&#x27;a.js&#x27;)console.log(a.name)//&#x27;morrain&#x27;a.name=&#x27;rename&#x27;var b=require(&#x27;a.js&#x27;)console.log(b.name)//&#x27;rename&#x27; &emsp;如上所示，第二次require模块A时，并没有重新加载并执行模块A。而是直接返回了第一次require时的结果，也就是模块A的module.exports. 二、AMD来看看AMD规范的实现 12&lt;script src=&quot;require.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;a.js&quot;&gt; &emsp;首先要在html文件中引入require.js工具库，就是这个库提供了定义模块，加载模块等功能。它提供了一个全局的define函数用来定义模块。所以在引入require.js文件中，在引入的其他文件，都可以使用define来定义模块define(id?,dependencies?,factory) &emsp; id:可选参数，用来定义模块的标识，如果没有提供该参数，就使用js文件名对于一个js文件只定义了一个模块时，这个参数是可以省略的。dependencies:可选参数，是一个数组，表示当前模块的依赖，如果没有依赖可以不穿factory:工厂方法，模块初始化要执行的函数或对象，如果为函数，它应该只被执行一次，返回值便是模块要导出的值，如果是对象，此对象应该为模块的输出值 所以模块A可以这么定义 1234567891011121314151617181920//a.jsdefine(function()&#123; var name=&#x27;morrain&#x27; var age =18 return &#123; name, getAge:()=&gt;age &#125;&#125;)//b.jsdefine([&#x27;a.js&#x27;],function(a)&#123; var name=&#x27;lilei&#x27; var age=15 console.log(a.name)//morrain console.log(a.getAge)//18 return&#123; name, getAge:()=&gt;age &#125;&#125;) &emsp;，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在回调函数中，等到加载完成之后，这个回调函数才会运行通过define方法，将代码定义为模块。当这个模块被require时，它开始加载它依赖的模块，当所有依赖的模块加载完成后，开始执行回调函数，返回值是该模块导出ed值。AMD的意思就是异步模块定义 三、CMD&emsp;Sea.js可以像Commonjs那样同步的形式书写模块代码的秘诀在于:当b.js模块被require时，b.js架加载后，Sea.js会扫描b.js的代码,找到require这个关键字，提取所有的依赖项，然后加载，等到依赖的所有模块加载完成后，执行回调函数，此时再执行到require(‘a.js’)这行代码时，a.js已经加载好在内存中了 四、ES6 Module语法&emsp;任何模块化，都必须考虑的两个问题就是导入依赖和导出接口。Es6 Module 也是如此，模块功能主要由两个命令构成:export 和import 。export 命令用于导出模块的对外接口，import命令用于导入其他模块导出的内容。 1234567891011121314//a.jsconst name=&#x27;a&#x27;const age=18function getAge()&#123; return age&#125;export default&#123; name, getAge&#125;//b.jsimport a from &#x27;a.js&#x27;console.log(name)//aconsole.log(age)//18 &emsp;显然，一个模块只能有一个默认输出，因此export default 命令只能使用一次，同时可以看到，这时import 命令后面，不需要再使用大括号了","categories":[{"name":"Vue3","slug":"Vue3","permalink":"http://example.com/categories/Vue3/"},{"name":"前端面试题","slug":"Vue3/前端面试题","permalink":"http://example.com/categories/Vue3/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"前端面试题","slug":"前端面试题","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Vue3项目构建的基本配置","slug":"Prettier + Eslint 代码格式化工具","date":"2023-03-12T08:59:45.000Z","updated":"2023-03-13T17:09:17.003Z","comments":true,"path":"2023/03/12/Prettier + Eslint 代码格式化工具/","link":"","permalink":"http://example.com/2023/03/12/Prettier%20+%20Eslint%20%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7/","excerpt":"Vue3项目构建的基本配置:Prettier + Eslint 代码格式化工具editorconfig统一开发格式可以去github上搜寻.editorconfig统一格式，然后在自己的项目中新建.editorconfig文件，并配置相关代码","text":"Vue3项目构建的基本配置:Prettier + Eslint 代码格式化工具editorconfig统一开发格式可以去github上搜寻.editorconfig统一格式，然后在自己的项目中新建.editorconfig文件，并配置相关代码 [*.&#123;js,jsx,ts,tsx,vue&#125;] indent_style = space indent_size = 2 trim_trailing_whitespace = true insert_final_newline = true # https://editorconfig.org root = true [*] charset = utf-8 indent_style = space # 缩进风格(tab | space) indent_size = 2 # 缩进大小 end_of_line = lf # 控制换行类型(if | cr | crlf) insert_final_newline = true # 去除行首的任意空白字符 trim_trailing_whitespace = true # 始终在文件末尾插入一个新行 [*.md] insert_final_newline = z trim_trailing_whitespace = false 开发时依赖 代码格式化工具 prettier1.安装 prettier 和 eslint 并且将他们两个兼容起来2.安装prettiernpm install prettier -D3.新建.prettierrc文件来配置文件 &#123; &quot;useTabs&quot;: false, &quot;tabWidth&quot;: 2, &quot;printWidth&quot;: 80, &quot;singleQuote&quot;: false, &quot;trailingComma&quot;: &quot;none&quot;, &quot;semi&quot;: true &#125; 4.新建.prettierignore文件来忽视不需要代码格式化的文件 /dist/* .local .output.js /node_modules/** **/*.svg **/*.sh /public/* 4.如果使vscode请安装&emsp;&emsp;如果直接使用的话，prettier和eslint会有冲突，我们可以安装另外两个来使他们兼容，并且按照prettier的代码格式。npm install eslint-plugin-prettier -Dnpm install eslint-config-prettier -D5.并且在.eslintrc.js的文件里的extends属性里最后一行添加配置，这样就能覆盖掉前面的配置，并且能够兼容prettier的代码格式 extends: [ &quot;plugin:prettier/recommended&quot; ], Commitizen是一个帮助我们编写规范commit message的工具1.安装Commitizennpm i commitizen -D2.安装cz-conventional-changelog并且初始化cz-conventional-changelog:npx commitizen init cz-conventional-changelog --save-dev --save-exact会自动在pack.json文件中配置全局安装使用 npx cz 来代替 git commit 代码提交验证1.commitlint: 安装，制定提交规范（采用默认）npm install --save-dev @commitlint/config-conventional @commitlint/cli2.新建commit.config.js并配置 module.exports = &#123; extends: [&#39;@commitlint/config-conventional&#39;] &#125; 3.使用huskynpx husky add .husky/commit-msg &quot;npx --no-install commitlint --edit $1&quot; vue.config.js 基本配置vue.config.js 是vue-cli的配置文件，而vue-cli是有webpack构建所以可以进行相关的配置1.配置方式一 outputDir:&#39;./build&#39;, configureWebpack: &#123; resolve: &#123; alias: &#123; components: &#39;@/component&#39;, &#125; &#125; &#125; 2.配置方式二 configureWebpack: (config) =&gt; &#123; config.resolve.alias = &#123; &#39;@&#39;:path.resolve(__dirname,&#39;src&#39;), components:&#39;@/components&#39; &#125; }","categories":[{"name":"Vue3","slug":"Vue3","permalink":"http://example.com/categories/Vue3/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"http://example.com/tags/Vue3/"}]}],"categories":[{"name":"Vue3","slug":"Vue3","permalink":"http://example.com/categories/Vue3/"},{"name":"前端面试题","slug":"Vue3/前端面试题","permalink":"http://example.com/categories/Vue3/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"前端面试题","slug":"前端面试题","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Vue3","slug":"Vue3","permalink":"http://example.com/tags/Vue3/"}]}